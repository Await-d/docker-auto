name: Auto Release Pipeline

on:
  push:
    branches:
      - main

permissions:
  contents: write
  packages: write

jobs:
  release-pipeline:
    runs-on: ubuntu-latest
    # Prevent GitHub Actions bot from triggering its own workflow
    if: github.event.pusher.name != 'github-actions[bot]' && !contains(github.event.head_commit.message, '[skip ci]')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for version bump necessity
        id: check_bump
        run: |
          # Skip version bump for merge commits or documentation-only changes
          if [[ "${{ github.event.head_commit.message }}" =~ ^Merge ]]; then
            echo "Skip version bump for merge commit"
            echo "should_bump=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if there are any significant changes (not just docs/readme)
          changed_files=$(git diff --name-only HEAD~1 HEAD || echo "")
          significant_changes=false

          # List of patterns that should trigger a version bump
          significant_patterns=(
            "src/"
            "lib/"
            "config/"
            "package.json"
            "Dockerfile"
            "docker-compose"
            "backend/"
            "frontend/"
            ".github/workflows/"
          )

          for file in $changed_files; do
            for pattern in "${significant_patterns[@]}"; do
              if [[ $file =~ $pattern ]]; then
                significant_changes=true
                break 2
              fi
            done
          done

          if [ "$significant_changes" = "true" ]; then
            echo "Found significant changes, version bump needed"
            echo "should_bump=true" >> $GITHUB_OUTPUT
          else
            echo "Only documentation/minor changes, skipping version bump"
            echo "should_bump=false" >> $GITHUB_OUTPUT
          fi

      - name: Calculate next version
        if: steps.check_bump.outputs.should_bump == 'true'
        id: version
        run: |
          # Get latest tag
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $latest_tag"

          # Remove 'v' prefix for version calculation
          version=${latest_tag#v}
          IFS='.' read -ra VERSION_PARTS <<< "$version"
          major=${VERSION_PARTS[0]:-0}
          minor=${VERSION_PARTS[1]:-0}
          patch=${VERSION_PARTS[2]:-0}

          # Determine version bump type based on commit message
          commit_message="${{ github.event.head_commit.message }}"

          if [[ $commit_message =~ ^feat(\(.+\))?!: ]] || [[ $commit_message =~ BREAKING[[:space:]]CHANGE ]] || [[ $commit_message =~ \[major\] ]]; then
            # Major version bump
            major=$((major + 1))
            minor=0
            patch=0
            echo "Major version bump"
          elif [[ $commit_message =~ ^feat(\(.+\))?: ]] || [[ $commit_message =~ \[minor\] ]]; then
            # Minor version bump
            minor=$((minor + 1))
            patch=0
            echo "Minor version bump"
          else
            # Patch version bump (default)
            patch=$((patch + 1))
            echo "Patch version bump"
          fi

          new_version="$major.$minor.$patch"
          new_tag="v$new_version"

          echo "New version: $new_version"
          echo "New tag: $new_tag"
          echo "version=$new_version" >> $GITHUB_OUTPUT
          echo "tag=$new_tag" >> $GITHUB_OUTPUT

      - name: Update VERSION file
        if: steps.check_bump.outputs.should_bump == 'true'
        run: |
          echo "${{ steps.version.outputs.version }}" > VERSION
          echo "VERSION=${{ steps.version.outputs.version }}" >> $GITHUB_ENV

      - name: Generate changelog
        if: steps.check_bump.outputs.should_bump == 'true'
        id: changelog
        run: |
          # Get commits since last tag
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$latest_tag" ]; then
            commits=$(git log --pretty=format:"- %s (%h)" --no-merges)
          else
            commits=$(git log ${latest_tag}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi

          # Create changelog
          changelog="## What's Changed\n\n$commits"

          # Save changelog to file for release
          echo -e "$changelog" > CHANGELOG.md

          # Set output for release notes (escape newlines)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo -e "$changelog" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Set up QEMU
        if: steps.check_bump.outputs.should_bump == 'true'
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: steps.check_bump.outputs.should_bump == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: steps.check_bump.outputs.should_bump == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME || 'await2719' }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        if: steps.check_bump.outputs.should_bump == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            await2719/docker-auto:${{ steps.version.outputs.tag }}
            await2719/docker-auto:latest
            await2719/docker-auto:${{ steps.version.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Create and push tag
        if: steps.check_bump.outputs.should_bump == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a "${{ steps.version.outputs.tag }}" -m "Release ${{ steps.version.outputs.tag }}"
          git push origin "${{ steps.version.outputs.tag }}"

      - name: Create GitHub Release
        if: steps.check_bump.outputs.should_bump == 'true'
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          release_name: Release ${{ steps.version.outputs.tag }}
          body: ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: false

      - name: Clean up old tags and releases
        if: steps.check_bump.outputs.should_bump == 'true'
        run: |
          # Keep only the last 50 tags/releases
          tags_to_delete=$(git tag -l --sort=-version:refname | tail -n +51)
          for tag in $tags_to_delete; do
            echo "Deleting old tag: $tag"
            git push origin --delete "$tag" 2>/dev/null || true
            git tag -d "$tag" 2>/dev/null || true
          done

      - name: Send Telegram notification
        if: steps.check_bump.outputs.should_bump == 'true' && success()
        run: |
          if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ] && [ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
            curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d chat_id="${{ secrets.TELEGRAM_CHAT_ID }}" \
              -d parse_mode="Markdown" \
              -d text="ğŸ‰ *Docker Auto Update System*

          ğŸš€ **New Release**: \`${{ steps.version.outputs.tag }}\`
          ğŸ“¦ **Repository**: [docker-auto](https://github.com/Await-d/docker-auto)
          ğŸ”— **Release**: [View Release](https://github.com/Await-d/docker-auto/releases/tag/${{ steps.version.outputs.tag }})
          ğŸ³ **Docker Image**: \`await2719/docker-auto:${{ steps.version.outputs.version }}\`

          ğŸ’¡ **Quick Start**:
          \`\`\`bash
          docker run -d await2719/docker-auto:${{ steps.version.outputs.version }}
          \`\`\`"
          fi