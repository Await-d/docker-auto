name: Docker Build and Test

on:
  pull_request:
    branches: [main, master]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'database/**'
      - 'docker-compose.yml'
      - 'Dockerfile*'
      - '.github/workflows/docker-build-test.yml'
  push:
    branches: [main, master]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'database/**'
      - 'docker-compose.yml'
      - 'Dockerfile*'

permissions:
  contents: read
  packages: read
  security-events: write

jobs:
  docker-build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [backend, frontend]
    name: Build ${{ matrix.service }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ matrix.service }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-${{ matrix.service }}-

      - name: Build Docker image (${{ matrix.service }})
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service }}
          file: ./${{ matrix.service }}/Dockerfile.dev
          target: development
          platforms: linux/amd64
          push: false
          tags: |
            docker-auto-${{ matrix.service }}:test
            docker-auto-${{ matrix.service }}:${{ github.sha }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
          load: true

      - name: Test Docker image (${{ matrix.service }})
        run: |
          echo "ğŸ” Testing ${{ matrix.service }} Docker image..."

          # Test if image was built successfully
          docker images docker-auto-${{ matrix.service }}:test

          # Test if container can start (basic health check)
          if [ "${{ matrix.service }}" = "backend" ]; then
            # Test backend container
            docker run --rm -d --name test-backend \
              -e APP_PORT=8080 \
              -e DB_HOST=localhost \
              -e DB_PORT=5432 \
              -e DB_NAME=test \
              -e DB_USER=test \
              -e DB_PASSWORD=test \
              docker-auto-backend:test

            # Wait a bit for the service to start
            sleep 10

            # Check if container is running
            if docker ps | grep -q test-backend; then
              echo "âœ… Backend container started successfully"
              docker logs test-backend
              docker stop test-backend
            else
              echo "âŒ Backend container failed to start"
              docker logs test-backend || true
              exit 1
            fi

          elif [ "${{ matrix.service }}" = "frontend" ]; then
            # Test frontend container
            docker run --rm -d --name test-frontend \
              -p 3001:3000 \
              docker-auto-frontend:test

            # Wait a bit for the service to start
            sleep 15

            # Check if container is running and responding
            if docker ps | grep -q test-frontend; then
              echo "âœ… Frontend container started successfully"

              # Try to curl the frontend (basic connectivity test)
              if curl -f http://localhost:3001/ > /dev/null 2>&1; then
                echo "âœ… Frontend is responding to HTTP requests"
              else
                echo "âš ï¸ Frontend container running but not responding (this might be normal for SPA)"
              fi

              docker logs test-frontend
              docker stop test-frontend
            else
              echo "âŒ Frontend container failed to start"
              docker logs test-frontend || true
              exit 1
            fi
          fi

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  docker-compose-test:
    runs-on: ubuntu-latest
    name: Test Docker Compose Setup

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create test environment file
        run: |
          cp .env.example .env

          # Override some settings for testing
          cat >> .env << EOF

          # Test overrides
          DB_DEBUG=true
          LOG_LEVEL=debug
          PROMETHEUS_ENABLED=true
          EOF

      - name: Test Docker Compose configuration
        run: |
          echo "ğŸ” Testing Docker Compose configuration..."

          # Validate compose file
          docker compose config --quiet
          echo "âœ… Docker Compose file is valid"

          # Test service definitions
          docker compose config --services

      - name: Start services with Docker Compose
        run: |
          echo "ğŸš€ Starting Docker Compose services..."

          # Start only core services (excluding optional ones)
          docker compose up -d postgres

          # Wait for database to be ready
          echo "â³ Waiting for database to be ready..."
          timeout=60
          while ! docker compose exec -T postgres pg_isready -U postgres -d dockerauto > /dev/null 2>&1; do
            timeout=$((timeout - 1))
            if [ $timeout -le 0 ]; then
              echo "âŒ Database failed to start within 60 seconds"
              docker compose logs postgres
              exit 1
            fi
            sleep 1
          done
          echo "âœ… Database is ready"

      - name: Test database initialization
        run: |
          echo "ğŸ” Testing database initialization..."

          # Check if tables were created
          tables=$(docker compose exec -T postgres psql -U postgres -d dockerauto -t -c "\dt" | grep -E "users|containers|images" | wc -l)

          if [ "$tables" -ge 3 ]; then
            echo "âœ… Database tables created successfully"
          else
            echo "âŒ Database initialization may have failed"
            docker compose exec -T postgres psql -U postgres -d dockerauto -c "\dt"
            exit 1
          fi

          # Check if admin user was created
          admin_exists=$(docker compose exec -T postgres psql -U postgres -d dockerauto -t -c "SELECT COUNT(*) FROM users WHERE username='admin';" | tr -d ' ')

          if [ "$admin_exists" = "1" ]; then
            echo "âœ… Admin user created successfully"
          else
            echo "âŒ Admin user creation failed"
            exit 1
          fi

      - name: Cleanup
        if: always()
        run: |
          echo "ğŸ§¹ Cleaning up..."
          docker compose down -v
          docker system prune -f

  security-scan:
    runs-on: ubuntu-latest
    name: Docker Security Scan

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build unified image for scanning
        run: |
          # Build unified Docker image for security scanning
          docker build -t docker-auto:scan . -f Dockerfile

      - name: Run Trivy security scan on unified image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'docker-auto:scan'
          format: 'sarif'
          output: 'docker-auto-trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'docker-auto-trivy-results.sarif'

      - name: Comment security scan results
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          script: |
            const fs = require('fs');

            let commentBody = `## ğŸ”’ Docker Security Scan Results\n\n`;

            // Read SARIF file and check for vulnerabilities
            try {
              const scanResults = JSON.parse(fs.readFileSync('docker-auto-trivy-results.sarif', 'utf8'));

              const vulns = scanResults.runs?.[0]?.results?.length || 0;

              commentBody += `### Unified Docker Image\n`;
              commentBody += vulns === 0 ? `âœ… No vulnerabilities found\n` : `âš ï¸ Found ${vulns} potential vulnerabilities\n`;

              if (vulns > 0) {
                commentBody += `\nğŸ“‹ **Action Required**: Review the security tab for detailed vulnerability information.\n`;
              }
            } catch (error) {
              commentBody += `âŒ Failed to parse security scan results: ${error.message}\n`;
            }

            commentBody += `\n---\n*Automated security scan by Docker Auto Update System ğŸ›¡ï¸*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });